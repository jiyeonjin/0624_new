# ğŸ§  ë¨¸ì‹ ëŸ¬ë‹(Machine Learning) ê°œìš” ì •ë¦¬
---

## ğŸ“Œ ë¨¸ì‹ ëŸ¬ë‹ì´ë€?

> **ë¨¸ì‹ ëŸ¬ë‹(Machine Learning)**ì€ ëª…ì‹œì ì¸ í”„ë¡œê·¸ë˜ë° ì—†ì´ ë°ì´í„°ë¥¼ í†µí•´ ì‹œìŠ¤í…œì´ í•™ìŠµí•˜ê³  ì˜ˆì¸¡ ë˜ëŠ” ê²°ì •ì„ ë‚´ë¦´ ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì¸ê³µì§€ëŠ¥(AI)ì˜ í•œ ë¶„ì•¼ì…ë‹ˆë‹¤.

- **ì£¼ìš” ëª©í‘œ**: ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ íŒ¨í„´ì„ í•™ìŠµí•˜ê³ , ì´ë¥¼ í† ëŒ€ë¡œ ë¯¸ë˜ì˜ ë°ì´í„°ì— ëŒ€í•´ ì˜ˆì¸¡í•˜ê±°ë‚˜ ë¶„ë¥˜
- **ì°¨ì´ì **: ì „í†µì  í”„ë¡œê·¸ë˜ë°ì€ ì‚¬ëŒì´ ê·œì¹™ì„ ëª…ì‹œí•˜ì§€ë§Œ, ë¨¸ì‹ ëŸ¬ë‹ì€ ë°ì´í„°ë¥¼ í†µí•´ ìŠ¤ìŠ¤ë¡œ ê·œì¹™ì„ í•™ìŠµ

---

## ğŸ§© ë¨¸ì‹ ëŸ¬ë‹ vs ë”¥ëŸ¬ë‹ vs ì¸ê³µì§€ëŠ¥

| êµ¬ë¶„         | ì„¤ëª… |
|--------------|------|
| **AI (ì¸ê³µì§€ëŠ¥)** | ì¸ê°„ì˜ ì§€ëŠ¥ì„ ëª¨ë°©í•œ ì‹œìŠ¤í…œ ì „ì²´ |
| **ML (ë¨¸ì‹ ëŸ¬ë‹)** | ë°ì´í„°ë¡œë¶€í„° í•™ìŠµí•˜ëŠ” AIì˜ í•œ ë¶„ì•¼ |
| **DL (ë”¥ëŸ¬ë‹)** | ì¸ê³µì‹ ê²½ë§(Neural Network)ì„ ì´ìš©í•˜ëŠ” ë¨¸ì‹ ëŸ¬ë‹ì˜ í•˜ìœ„ ë¶„ì•¼ |

---

## ğŸ§­ ë¨¸ì‹ ëŸ¬ë‹ì˜ ë¶„ë¥˜

### 1. ì§€ë„í•™ìŠµ (Supervised Learning)
- **ì •ë‹µì´ ìˆëŠ” ë°ì´í„°(ë ˆì´ë¸”)ë¡œ í•™ìŠµ**
- âœ… ì˜ˆ: ì´ë©”ì¼ ìŠ¤íŒ¸ ë¶„ë¥˜, ì§‘ê°’ ì˜ˆì¸¡

| ì•Œê³ ë¦¬ì¦˜ | ì„¤ëª… |
|----------|------|
| ì„ í˜• íšŒê·€ | ì—°ì†í˜• ìˆ«ì ì˜ˆì¸¡ |
| ë¡œì§€ìŠ¤í‹± íšŒê·€ | ì´ì§„ ë¶„ë¥˜ |
| ì˜ì‚¬ê²°ì •ë‚˜ë¬´ | íŠ¸ë¦¬ êµ¬ì¡° ê¸°ë°˜ ë¶„ë¥˜/íšŒê·€ |
| KNN | ì´ì›ƒ ê¸°ë°˜ ì˜ˆì¸¡ |
| SVM | ë§ˆì§„ ìµœëŒ€í™” ë¶„ë¥˜ |

---

### 2. ë¹„ì§€ë„í•™ìŠµ (Unsupervised Learning)
- **ì •ë‹µì´ ì—†ëŠ” ë°ì´í„°ë¡œ íŒ¨í„´ í•™ìŠµ**
- âœ… ì˜ˆ: ê³ ê° êµ°ì§‘í™”, ì°¨ì› ì¶•ì†Œ

| ì•Œê³ ë¦¬ì¦˜ | ì„¤ëª… |
|----------|------|
| K-Means | ë°ì´í„° êµ°ì§‘í™” |
| PCA | ì°¨ì› ì¶•ì†Œ |
| ê³„ì¸µ êµ°ì§‘í™” | íŠ¸ë¦¬ ê¸°ë°˜ êµ°ì§‘í™” |

---

### 3. ê°•í™”í•™ìŠµ (Reinforcement Learning)
- **ë³´ìƒì„ í†µí•´ ìµœì ì˜ í–‰ë™ í•™ìŠµ**
- âœ… ì˜ˆ: ê²Œì„, ë¡œë´‡ ì œì–´, ììœ¨ì£¼í–‰

| ìš©ì–´ | ì„¤ëª… |
|------|------|
| ì—ì´ì „íŠ¸ | í•™ìŠµì„ ìˆ˜í–‰í•˜ëŠ” ì£¼ì²´ |
| í™˜ê²½ | ì—ì´ì „íŠ¸ê°€ í–‰ë™í•˜ëŠ” ì„¸ê³„ |
| ìƒíƒœ | í˜„ì¬ í™˜ê²½ì˜ ì •ë³´ |
| í–‰ë™ | ì—ì´ì „íŠ¸ì˜ ì„ íƒ |
| ë³´ìƒ | í–‰ë™ì˜ ê²°ê³¼ë¡œ ë°›ëŠ” í”¼ë“œë°± |

---

## ğŸ”¨ ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë³¸ ìš©ì–´

| ìš©ì–´ | ì„¤ëª… |
|------|------|
| ë°ì´í„°ì…‹ (Dataset) | í•™ìŠµì— ì‚¬ìš©í•˜ëŠ” ë°ì´í„° ëª¨ìŒ |
| íŠ¹ì§• (Feature) | ë°ì´í„°ì˜ ì…ë ¥ ë³€ìˆ˜ (X) |
| ë¼ë²¨ (Label) | ì •ë‹µ ë˜ëŠ” ì˜ˆì¸¡ ëŒ€ìƒ

## ë¨¸ì‹ ëŸ¬ë‹ ì˜ˆì œ ì½”ë“œ ë¶„ì„
```bash
!pip install opencv-python tensorflow scikit-learn matplotlib pillow
import cv2
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
import matplotlib.pyplot as plt
import os
from PIL import Image

class AutonomousDrivingMLSystem:
    def __init__(self):
        self.lane_detector = None
        self.traffic_sign_classifier = None
        self.speed_predictor = None
        
    def preprocess_image(self, image_path):
        """ì´ë¯¸ì§€ ì „ì²˜ë¦¬ í•¨ìˆ˜"""
        image = cv2.imread(image_path)
        if image is None:
            return None
        
        # í¬ê¸° ì¡°ì •
        image = cv2.resize(image, (224, 224))
        # ì •ê·œí™”
        image = image.astype(np.float32) / 255.0
        return image
    
    def detect_lane_features(self, image):
        """ì°¨ì„  íŠ¹ì§• ì¶”ì¶œ"""
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        
        # ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì ìš©
        blur = cv2.GaussianBlur(gray, (5, 5), 0)
        
        # ì—ì§€ ê²€ì¶œ
        edges = cv2.Canny(blur, 50, 150)
        
        # ê´€ì‹¬ ì˜ì—­ ì„¤ì • (ë„ë¡œ í•˜ë‹¨ë¶€)
        height = edges.shape[0]
        mask = np.zeros_like(edges)
        polygon = np.array([[
            (0, height),
            (edges.shape[1], height),
            (edges.shape[1], height//2),
            (0, height//2)
        ]], np.int32)
        cv2.fillPoly(mask, polygon, 255)
        masked_edges = cv2.bitwise_and(edges, mask)
        
        # í—ˆí”„ ë³€í™˜ìœ¼ë¡œ ì§ì„  ê²€ì¶œ
        lines = cv2.HoughLinesP(masked_edges, 1, np.pi/180, 
                               threshold=50, minLineLength=100, maxLineGap=50)
        
        features = []
        if lines is not None:
            for line in lines:
                x1, y1, x2, y2 = line[0]
                # ê¸°ìš¸ê¸°ì™€ ê¸¸ì´ ê³„ì‚°
                if x2 - x1 != 0:
                    slope = (y2 - y1) / (x2 - x1)
                    length = np.sqrt((x2-x1)**2 + (y2-y1)**2)
                    features.extend([slope, length, x1, y1, x2, y2])
        
        # ê³ ì • ê¸¸ì´ë¡œ ë§ì¶”ê¸°
        while len(features) < 30:
            features.append(0)
        return features[:30]
    
    def build_traffic_sign_cnn(self):
        """êµí†µ í‘œì§€íŒ ë¶„ë¥˜ë¥¼ ìœ„í•œ CNN ëª¨ë¸"""
        model = models.Sequential([
            layers.Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 3)),
            layers.MaxPooling2D((2, 2)),
            layers.Conv2D(64, (3, 3), activation='relu'),
            layers.MaxPooling2D((2, 2)),
            layers.Conv2D(64, (3, 3), activation='relu'),
            layers.Flatten(),
            layers.Dense(64, activation='relu'),
            layers.Dropout(0.5),
            layers.Dense(4, activation='softmax')  # 4ê°œ í´ë˜ìŠ¤: ì •ì§€, ì§ì§„, ì¢ŒíšŒì „, ìš°íšŒì „
        ])
        
        model.compile(optimizer='adam',
                     loss='sparse_categorical_crossentropy',
                     metrics=['accuracy'])
        return model
    
    def generate_sample_data(self):
        """ìƒ˜í”Œ ë°ì´í„° ìƒì„± (ì‹¤ì œë¡œëŠ” ì‹¤ì œ ë„ë¡œ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©)"""
        # ì°¨ì„  íŠ¹ì§• ë°ì´í„° ìƒì„±
        np.random.seed(42)
        lane_features = []
        lane_decisions = []
        
        for i in range(1000):
            # 30ê°œ íŠ¹ì§• (ê¸°ìš¸ê¸°, ê¸¸ì´, ì¢Œí‘œ ë“±)
            features = np.random.randn(30)
            
            # ì°¨ì„  ì¤‘ì•™ ìœ ì§€ ì—¬ë¶€ ê²°ì • (0: ì¢ŒíšŒì „, 1: ì§ì§„, 2: ìš°íšŒì „)
            if features[0] < -0.5:  # ì™¼ìª½ ê¸°ìš¸ê¸°ê°€ ê°•í•¨
                decision = 0  # ìš°íšŒì „ìœ¼ë¡œ ë³´ì •
            elif features[0] > 0.5:  # ì˜¤ë¥¸ìª½ ê¸°ìš¸ê¸°ê°€ ê°•í•¨  
                decision = 2  # ì¢ŒíšŒì „ìœ¼ë¡œ ë³´ì •
            else:
                decision = 1  # ì§ì§„
                
            lane_features.append(features)
            lane_decisions.append(decision)
        
        # êµí†µ í‘œì§€íŒ ì´ë¯¸ì§€ ë°ì´í„° ìƒì„± (ì‹¤ì œë¡œëŠ” ì‹¤ì œ í‘œì§€íŒ ì´ë¯¸ì§€)
        sign_images = np.random.rand(500, 64, 64, 3)
        sign_labels = np.random.randint(0, 4, 500)
        
        return np.array(lane_features), np.array(lane_decisions), sign_images, sign_labels
    
    def train_lane_keeping_system(self):
        """ì°¨ì„  ìœ ì§€ ì‹œìŠ¤í…œ í›ˆë ¨"""
        print("ì°¨ì„  ìœ ì§€ ì‹œìŠ¤í…œ í›ˆë ¨ ì‹œì‘...")
        
        # ìƒ˜í”Œ ë°ì´í„° ìƒì„±
        lane_features, lane_decisions, _, _ = self.generate_sample_data()
        
        # í›ˆë ¨/í…ŒìŠ¤íŠ¸ ë°ì´í„° ë¶„í• 
        X_train, X_test, y_train, y_test = train_test_split(
            lane_features, lane_decisions, test_size=0.2, random_state=42
        )
        
        # ëœë¤ í¬ë ˆìŠ¤íŠ¸ ë¶„ë¥˜ê¸° í›ˆë ¨
        self.lane_detector = RandomForestClassifier(n_estimators=100, random_state=42)
        self.lane_detector.fit(X_train, y_train)
        
        # ì„±ëŠ¥ í‰ê°€
        y_pred = self.lane_detector.predict(X_test)
        accuracy = accuracy_score(y_test, y_pred)
        
        print(f"ì°¨ì„  ìœ ì§€ ì‹œìŠ¤í…œ ì •í™•ë„: {accuracy:.3f}")
        print("\në¶„ë¥˜ ë³´ê³ ì„œ:")
        print(classification_report(y_test, y_pred, 
                                   target_names=['ì¢ŒíšŒì „', 'ì§ì§„', 'ìš°íšŒì „']))
        
        return accuracy
    
    def train_traffic_sign_classifier(self):
        """êµí†µ í‘œì§€íŒ ë¶„ë¥˜ê¸° í›ˆë ¨"""
        print("\nêµí†µ í‘œì§€íŒ ë¶„ë¥˜ê¸° í›ˆë ¨ ì‹œì‘...")
        
        # ìƒ˜í”Œ ë°ì´í„° ìƒì„±
        _, _, sign_images, sign_labels = self.generate_sample_data()
        
        # í›ˆë ¨/í…ŒìŠ¤íŠ¸ ë°ì´í„° ë¶„í• 
        X_train, X_test, y_train, y_test = train_test_split(
            sign_images, sign_labels, test_size=0.2, random_state=42
        )
        
        # CNN ëª¨ë¸ ìƒì„± ë° í›ˆë ¨
        self.traffic_sign_classifier = self.build_traffic_sign_cnn()
        
        history = self.traffic_sign_classifier.fit(
            X_train, y_train,
            epochs=10,
            batch_size=32,
            validation_data=(X_test, y_test),
            verbose=1
        )
        
        # ì„±ëŠ¥ í‰ê°€
        test_loss, test_accuracy = self.traffic_sign_classifier.evaluate(X_test, y_test, verbose=0)
        print(f"\nêµí†µ í‘œì§€íŒ ë¶„ë¥˜ ì •í™•ë„: {test_accuracy:.3f}")
        
        return test_accuracy
    
    def predict_driving_action(self, image_path):
        """ì£¼í–‰ í–‰ë™ ì˜ˆì¸¡"""
        if not os.path.exists(image_path):
            print("ì´ë¯¸ì§€ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return None
        
        # ì´ë¯¸ì§€ ì „ì²˜ë¦¬
        image = self.preprocess_image(image_path)
        if image is None:
            return None
        
        # ì°¨ì„  íŠ¹ì§• ì¶”ì¶œ
        lane_features = self.detect_lane_features((image * 255).astype(np.uint8))
        
        # ì°¨ì„  ê¸°ë°˜ ì£¼í–‰ ë°©í–¥ ì˜ˆì¸¡
        if self.lane_detector:
            lane_decision = self.lane_detector.predict([lane_features])[0]
            lane_actions = ['ì¢ŒíšŒì „', 'ì§ì§„', 'ìš°íšŒì „']
            
            print(f"ì°¨ì„  ë¶„ì„ ê²°ê³¼: {lane_actions[lane_decision]}")
        
        # êµí†µ í‘œì§€íŒ ë¶„ë¥˜ (64x64 í¬ê¸°ë¡œ ì¡°ì •)
        if self.traffic_sign_classifier:
            sign_image = cv2.resize((image * 255).astype(np.uint8), (64, 64))
            sign_image = np.expand_dims(sign_image.astype(np.float32) / 255.0, axis=0)
            
            sign_prediction = self.traffic_sign_classifier.predict(sign_image, verbose=0)
            sign_class = np.argmax(sign_prediction[0])
            sign_confidence = np.max(sign_prediction[0])
            
            sign_names = ['ì •ì§€', 'ì§ì§„', 'ì¢ŒíšŒì „', 'ìš°íšŒì „']
            print(f"êµí†µí‘œì§€íŒ ì¸ì‹: {sign_names[sign_class]} (ì‹ ë¢°ë„: {sign_confidence:.3f})")
        
        return lane_decision if self.lane_detector else None

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("=== ììœ¨ì£¼í–‰ ì§€ë„í•™ìŠµ ì‹œìŠ¤í…œ ===\n")
    
    # ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    autonomous_system = AutonomousDrivingMLSystem()
    
    # ëª¨ë¸ í›ˆë ¨
    lane_accuracy = autonomous_system.train_lane_keeping_system()
    sign_accuracy = autonomous_system.train_traffic_sign_classifier()
    
    print(f"\n=== í›ˆë ¨ ì™„ë£Œ ===")
    print(f"ì°¨ì„  ìœ ì§€ ì‹œìŠ¤í…œ ì •í™•ë„: {lane_accuracy:.1%}")
    print(f"êµí†µí‘œì§€íŒ ë¶„ë¥˜ ì •í™•ë„: {sign_accuracy:.1%}")
    
    # ìƒ˜í”Œ ì´ë¯¸ì§€ë¡œ í…ŒìŠ¤íŠ¸ (ì‹¤ì œ íŒŒì¼ì´ ìˆë‹¤ë©´)
    # test_image = "sample_road.jpg"
    # result = autonomous_system.predict_driving_action(test_image)

if __name__ == "__main__":
    main()
```



