# 칼만 필터 정리

[![GitHub stars](https://img.shields.io/github/stars/username/kalman-filter-guide.svg?style=social&label=Star)](https://github.com/username/kalman-filter-guide)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

> 노이즈가 많은 센서 데이터를 결합하여 실시간으로 최적의 상태를 추정하는 칼만 필터 정리하기

## 📋 목차

- [첫 번째 강의: 칼만 필터의 기초](#-첫-번째-강의-칼만-필터의-기초)
- [두 번째 강의: 센서 융합과 칼만 필터](#-두-번째-강의-센서-융합과-칼만-필터)
- [세 번째 강의: 1차원 칼만 필터 심화](#-세-번째-강의-1차원-칼만-필터-심화)
- [전체 강의 총정리](#-전체-강의-총정리)

---

## 📚 첫 번째 강의: 칼만 필터의 기초

### 🎯 칼만 필터의 개념
칼만 필터(Kalman Filter)는 1960년 루돌프 칼만이 개발한 **최적 상태 추정 알고리즘**입니다. 노이즈가 포함된 불완전한 측정값들을 이용해 시스템의 실제 상태를 가장 정확하게 추정하는 수학적 도구입니다.

### 💡 칼만 필터의 핵심 아이디어
- **베이지안 추론**: 이전 정보와 새로운 측정값을 결합
- **재귀적 추정**: 모든 과거 데이터를 저장할 필요 없이 현재 상태만으로 최적 추정
- **불확실성 관리**: 추정값의 신뢰도(공분산)도 함께 계산

### ⚙️ 칼만 필터의 동작 원리

#### 1단계: 예측 (Predict)
```
다음 상태를 모델로 예측
x̂(k|k-1) = F * x̂(k-1|k-1) + B * u(k)
P(k|k-1) = F * P(k-1|k-1) * F^T + Q
```

#### 2단계: 측정 (Measure)
```
센서로부터 새로운 측정값 z(k) 획득
```

#### 3단계: 보정 (Update)
```
칼만 게인 계산: K(k) = P(k|k-1) * H^T * (H * P(k|k-1) * H^T + R)^(-1)
상태 업데이트: x̂(k|k) = x̂(k|k-1) + K(k) * (z(k) - H * x̂(k|k-1))
공분산 업데이트: P(k|k) = (I - K(k) * H) * P(k|k-1)
```

### 🌍 실생활 적용 예시

#### 자율주행 자동차
- GPS, 라이다, 카메라 데이터 융합
- 차량의 위치, 속도, 가속도 실시간 추정
- 장애물 추적 및 경로 예측

#### 드론 제어
- IMU, GPS, 기압계 데이터 통합
- 3D 위치 및 자세 안정화
- 바람 등 외부 교란 보정

#### 로봇 네비게이션
- 엔코더, 라이다 스캔 매칭
- SLAM(동시 위치추정 및 지도작성)
- 동적 환경에서의 경로 계획

### 💻 간단한 1차원 칼만 필터 코드

```python
import random

# 측정 오차 (센서 노이즈 등)
measurement_error = 4.0  # 분산 2.0^2 = 4.0

# 실제 위치는 0, 노이즈가 섞인 측정값 10개 생성
measurements = [0 + random.gauss(0, 2.0) for _ in range(10)]

estimate = 0.0  # 초기 추정값
error_in_estimate = 1.0  # 초기 추정 오차

# 칼만 필터 적용
for z in measurements:
    # 칼만 이득 계산
    K = error_in_estimate / (error_in_estimate + measurement_error)
    # 추정값 갱신
    estimate = estimate + K * (z - estimate)
    # 추정 오차 갱신
    error_in_estimate = (1 - K) * error_in_estimate

print(f"최종 수정값: {estimate:.2f}")
```


### 📊 코드 분석

#### **Step 1: 칼만 게인 계산**
```python
K = error_in_estimate / (error_in_estimate + measurement_error)
```

**수학적 의미:**
- K = P / (P + R)
- **P**: 현재 추정 불확실성
- **R**: 측정 노이즈 분산
- **결과**: 0 ≤ K ≤ 1

**해석:**
- **K ≈ 0**: 측정값보다 현재 추정을 더 신뢰 (R >> P)
- **K ≈ 1**: 현재 추정보다 측정값을 더 신뢰 (P >> R)
- **K = 0.5**: 추정과 측정을 동등하게 신뢰 (P = R)

#### **Step 2: 추정값 갱신**
```python
estimate = estimate + K * (z - estimate)
```

**수학적 의미:**
- x̂ₙₑw = x̂ₒₗd + K × (측정값 - x̂ₒₗd)
- **(z - estimate)**: **혁신(Innovation)** - 측정값과 예측값의 차이
- **K × 혁신**: 보정량

**해석:**
- 현재 추정값을 측정값 방향으로 K만큼 조정
- 가중 평균의 개념: (1-K) × 추정 + K × 측정

#### **Step 3: 불확실성 갱신**
```python
error_in_estimate = (1 - K) * error_in_estimate
```

**수학적 의미:**
- Pₙₑw = (1 - K) × Pₒₗd
- 측정 후 항상 불확실성이 감소

**해석:**
- 새로운 정보(측정값)를 얻으면 불확실성 감소
- K가 클수록 (측정을 더 신뢰) 불확실성이 더 많이 감소

---

## 🎯 핵심 개념 정리

### 1️⃣ 이 코드의 특징
- **정적 시스템**: 실제 값이 변하지 않음 (위치 = 0 고정)
- **측정만 있음**: 동역학 모델 없이 순수 측정 기반 추정
- **1차원**: 가장 단순한 형태의 칼만 필터

### 2️⃣ 칼만 필터의 핵심 아이디어
```python
# 이전 추정 + 보정 = 새로운 추정
새로운_추정 = 이전_추정 + 칼만_게인 × (측정값 - 이전_추정)
```

### 3️⃣ 불확실성의 역할
- **높은 불확실성** → **높은 칼만 게인** → **측정값에 더 의존**
- **낮은 불확실성** → **낮은 칼만 게인** → **현재 추정을 더 신뢰**

---

## 📡 두 번째 강의: 센서 융합과 칼만 필터

### 🤔 왜 센서 융합이 필요한가?

#### 단일 센서의 한계
- **노이즈와 오차**: 모든 센서는 불완전함
- **환경 의존성**: 특정 조건에서 성능 저하
- **단일 실패점**: 센서 고장 시 시스템 전체 마비
- **제한된 정보**: 하나의 센서로는 전체 상황 파악 어려움

#### 센서 융합의 장점
- **정확도 향상**: 여러 측정값의 통계적 결합
- **신뢰성 증대**: 센서 간 상호 검증
- **강건성**: 일부 센서 실패에도 동작 지속
- **완전한 상태 추정**: 다양한 물리량 동시 측정

### 📊 주요 센서 비교: GPS vs IMU

| 특성 | GPS | IMU (관성측정장치) |
|------|-----|-------------------|
| **장점** | • 절대 위치 정보<br>• 장기간 드리프트 없음<br>• 글로벌 좌표계 | • 높은 샘플링 주파수<br>• 실내/터널에서도 동작<br>• 짧은 지연시간 |
| **단점** | • 실내에서 신호 차단<br>• 낮은 업데이트 주파수<br>• 날씨/건물 영향 | • 시간에 따른 드리프트<br>• 적분 오차 누적<br>• 바이어스와 노이즈 |
| **업데이트 주파수** | 1-10 Hz | 100-1000 Hz |
| **정확도** | 수 미터 | 단기간 매우 정확 |

### 🔄 센서 융합의 상호 보완 관계

#### GPS + IMU 융합의 시너지
- **GPS**: 장기간 안정성, 절대 기준점 제공
- **IMU**: 고주파 업데이트, 순간적 움직임 감지
- **결합 효과**: GPS로 IMU 드리프트 보정, IMU로 GPS 갭 보간

#### 융합 과정의 시각적 이해
```
시간 축: |-------|-------|-------|-------|
GPS:     ●               ●               ●
IMU:     ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
융합:    ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
```

### ⚡ 칼만 필터의 센서 융합 과정

#### 1단계: 다중 센서 모델링
```python
# 상태 벡터: [위치, 속도]
x = [position, velocity]

# GPS 측정 모델
H_gps = [1, 0]  # 위치만 측정

# IMU 측정 모델  
H_imu = [0, 1]  # 가속도에서 속도 유도
```

#### 2단계: 비동기 센서 처리
```python
def sensor_fusion_step(dt):
    # 예측 (시스템 동역학)
    predict(dt)
    
    # GPS 데이터 있으면 위치 업데이트
    if gps_available:
        update_with_gps(gps_measurement)
    
    # IMU 데이터로 속도/가속도 업데이트
    if imu_available:
        update_with_imu(imu_measurement)
```

#### 3단계: 적응적 노이즈 조정
```python
# 센서 품질에 따른 노이즈 조정
if gps_signal_strong:
    R_gps = low_noise
else:
    R_gps = high_noise
```

### 📈 센서 융합 효과 시각화

#### 융합 전후 비교
- **GPS만 사용**: 계단식 위치 추정, 갭 구간 정보 없음
- **IMU만 사용**: 부드러운 추정이지만 시간에 따른 드리프트
- **융합 결과**: GPS의 정확성 + IMU의 연속성

#### 불확실성의 변화
- GPS 측정 시: 위치 불확실성 급격히 감소
- IMU 업데이트: 속도 불확실성 감소, 위치는 점진적 증가
- 융합 효과: 전체적인 불확실성 최소화

### 🎯 센서 융합 핵심 원리
> **각 센서의 장점은 살리고 단점은 보완하여, 단일 센서로는 불가능한 정확하고 연속적인 상태 추정을 실현합니다.**

---

## 🔧 세 번째 강의: 1차원 칼만 필터 심화

### 💻 상세한 1차원 칼만 필터 구현

```python
import numpy as np
import matplotlib.pyplot as plt

class DetailedKalmanFilter1D:
    def __init__(self, initial_state, initial_covariance, process_noise, measurement_noise):
        """
        1차원 칼만 필터 초기화
        
        Args:
            initial_state: 초기 상태 추정값
            initial_covariance: 초기 추정 불확실성
            process_noise: 시스템 모델 노이즈 (Q)
            measurement_noise: 센서 측정 노이즈 (R)
        """
        # 상태 추정값과 공분산
        self.x = initial_state
        self.P = initial_covariance
        
        # 노이즈 매개변수
        self.Q = process_noise
        self.R = measurement_noise
        
        # 상태 전이 모델 (등속 운동)
        self.F = 1.0  # 1차원에서는 스칼라
        self.H = 1.0  # 측정 모델
        
        # 기록용
        self.history = {
            'states': [],
            'covariances': [],
            'kalman_gains': [],
            'innovations': []
        }
    
    def predict(self):
        """
        예측 단계 (Prediction Step)
        - 시스템 동역학에 따른 다음 상태 예측
        - 불확실성 증가 (시스템 노이즈 추가)
        """
        # 상태 예측: x̂(k|k-1) = F * x̂(k-1|k-1)
        self.x = self.F * self.x
        
        # 공분산 예측: P(k|k-1) = F * P(k-1|k-1) * F^T + Q
        self.P = self.F * self.P * self.F + self.Q
        
        print(f"예측 후 - 상태: {self.x:.3f}, 불확실성: {self.P:.3f}")
    
    def update(self, measurement):
        """
        갱신 단계 (Update Step)
        - 측정값으로 상태 추정값 보정
        - 불확실성 감소
        """
        # 혁신(innovation): 측정값과 예측값의 차이
        innovation = measurement - self.H * self.x
        
        # 혁신 공분산: S = H * P * H^T + R
        S = self.H * self.P * self.H + self.R
        
        # 칼만 게인: K = P * H^T * S^(-1)
        K = self.P * self.H / S
        
        # 상태 갱신: x̂(k|k) = x̂(k|k-1) + K * innovation
        self.x = self.x + K * innovation
        
        # 공분산 갱신: P(k|k) = (I - K * H) * P(k|k-1)
        self.P = (1 - K * self.H) * self.P
        
        # 기록 저장
        self.history['states'].append(self.x)
        self.history['covariances'].append(self.P)
        self.history['kalman_gains'].append(K)
        self.history['innovations'].append(innovation)
        
        print(f"갱신 후 - 상태: {self.x:.3f}, 불확실성: {self.P:.3f}, 칼만게인: {K:.3f}")
        
        return self.x, self.P

# 실제 적용 예제: 온도 센서 데이터 필터링
def temperature_tracking_example():
    """실제 온도를 추정하는 예제"""
    
    # 실제 온도 (알려지지 않은 참값)
    true_temperature = 25.0
    
    # 노이즈가 있는 센서 측정값 생성
    np.random.seed(42)
    measurements = true_temperature + np.random.normal(0, 2, 20)
    
    # 칼만 필터 초기화
    kf = DetailedKalmanFilter1D(
        initial_state=20.0,      # 초기 추정: 20도
        initial_covariance=10.0,  # 초기 불확실성이 큼
        process_noise=0.01,       # 온도는 천천히 변함
        measurement_noise=4.0     # 센서 노이즈 분산
    )
    
    estimates = []
    uncertainties = []
    
    print("=== 온도 센서 칼만 필터링 ===")
    
    for i, measurement in enumerate(measurements):
        print(f"\n시간 {i+1}: 측정값 = {measurement:.2f}°C")
        
        # 칼만 필터 단계 실행
        kf.predict()
        estimate, uncertainty = kf.update(measurement)
        
        estimates.append(estimate)
        uncertainties.append(uncertainty)
    
    # 결과 시각화
    plt.figure(figsize=(12, 8))
    
    # 상태 추정 결과
    plt.subplot(2, 2, 1)
    plt.plot(measurements, 'r.', label='측정값', alpha=0.7)
    plt.plot(estimates, 'b-', label='칼만 필터 추정', linewidth=2)
    plt.axhline(y=true_temperature, color='g', linestyle='--', label='실제 온도')
    plt.fill_between(range(len(estimates)), 
                     np.array(estimates) - np.sqrt(uncertainties),
                     np.array(estimates) + np.sqrt(uncertainties),
                     alpha=0.3, label='±1σ 신뢰구간')
    plt.xlabel('시간')
    plt.ylabel('온도 (°C)')
    plt.title('칼만 필터 온도 추정')
    plt.legend()
    plt.grid(True)
    
    # 불확실성 변화
    plt.subplot(2, 2, 2)
    plt.plot(uncertainties, 'g-', linewidth=2)
    plt.xlabel('시간')
    plt.ylabel('분산')
    plt.title('추정 불확실성 변화')
    plt.grid(True)
    
    # 칼만 게인 변화
    plt.subplot(2, 2, 3)
    plt.plot(kf.history['kalman_gains'], 'm-', linewidth=2)
    plt.xlabel('시간')
    plt.ylabel('칼만 게인')
    plt.title('칼만 게인 변화')
    plt.grid(True)
    
    # 혁신(잔차) 분석
    plt.subplot(2, 2, 4)
    plt.plot(kf.history['innovations'], 'c-', linewidth=2)
    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.xlabel('시간')
    plt.ylabel('혁신 (측정값 - 예측값)')
    plt.title('혁신 시계열')
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    print(f"\n=== 최종 결과 ===")
    print(f"실제 온도: {true_temperature:.2f}°C")
    print(f"최종 추정: {estimates[-1]:.2f}°C")
    print(f"추정 오차: {abs(estimates[-1] - true_temperature):.2f}°C")
    print(f"최종 불확실성: {uncertainties[-1]:.4f}")

# 실행
temperature_tracking_example()
```

### 🔍 코드의 각 라인과 칼만 필터 이론 연결

#### 예측 단계 (Predict)
```python
# 상태 예측
self.x = self.F * self.x
```
→ **이론**: x̂(k|k-1) = F·x̂(k-1|k-1)
→ **의미**: 이전 상태에서 시스템 모델로 다음 상태 예측

```python
# 공분산 예측
self.P = self.F * self.P * self.F + self.Q
```
→ **이론**: P(k|k-1) = F·P(k-1|k-1)·F^T + Q
→ **의미**: 예측 과정에서 불확실성 증가 (시스템 노이즈 추가)

#### 갱신 단계 (Update)
```python
# 칼만 게인 계산
K = self.P * self.H / S
```
→ **이론**: K = P·H^T·S^(-1)
→ **의미**: 예측과 측정값 중 어느 것을 더 신뢰할지 결정

```python
# 상태 갱신
self.x = self.x + K * innovation
```
→ **이론**: x̂(k|k) = x̂(k|k-1) + K·(z - H·x̂(k|k-1))
→ **의미**: 측정값과 예측값의 가중 평균으로 최적 추정

### ⚠️ 칼만 필터의 근본적인 한계

#### 1. 선형성 가정 (Linearity Assumption)
```python
# 칼만 필터는 선형 시스템만 처리 가능
x(k) = F * x(k-1) + B * u(k) + w(k)  # 선형 상태 방정식
z(k) = H * x(k) + v(k)               # 선형 측정 방정식
```

**문제상황**:
- 회전 운동 (삼각함수 포함)
- 비선형 센서 특성
- 복잡한 물리 현상

**한계 예시**:
```python
# 이런 비선형 시스템은 처리 불가
def nonlinear_model(x):
    return np.sin(x) + x**2  # 비선형 함수
```

#### 2. 가우시안 노이즈 가정
```python
# 모든 노이즈가 정규분포를 따른다고 가정
process_noise ~ N(0, Q)      # 시스템 노이즈
measurement_noise ~ N(0, R)  # 센서 노이즈
```

**문제상황**:
- 이상치(outlier)가 많은 센서
- 비대칭 노이즈 분포
- 간헐적 대형 오차

#### 3. 모델 정확성 의존
- 잘못된 F, H 행렬 설정 시 성능 저하
- Q, R 매개변수 튜닝의 어려움
- 시변 시스템에 대한 적응성 부족

### 🚀 확장된 칼만 필터의 필요성

#### Extended Kalman Filter (EKF)
```python
# 비선형 함수를 선형화하여 사용
def ekf_predict(x, dt):
    # 비선형 상태 전이
    x_pred = nonlinear_f(x, dt)
    
    # 야코비안 행렬로 선형화
    F = jacobian_f(x, dt)
    P_pred = F @ P @ F.T + Q
    
    return x_pred, P_pred
```

**장점**: 비선형 시스템 처리 가능
**단점**: 야코비안 계산 복잡, 선형화 오차

#### Unscented Kalman Filter (UKF)
```python
# 시그마 포인트로 비선형성 근사
def ukf_predict(x, P):
    # 시그마 포인트 생성
    sigma_points = generate_sigma_points(x, P)
    
    # 각 포인트를 비선형 함수에 통과
    transformed_points = [nonlinear_f(sp) for sp in sigma_points]
    
    # 통계적으로 평균과 공분산 추정
    x_pred = weighted_mean(transformed_points)
    P_pred = weighted_covariance(transformed_points)
    
    return x_pred, P_pred
```

**장점**: 야코비안 불필요, 더 정확한 비선형 근사
**단점**: 계산량 증가

### 📊 한계 극복 전략 비교

| 특성 | 칼만 필터 | EKF | UKF |
|------|-----------|-----|-----|
| **적용 대상** | 선형 시스템 | 약한 비선형 | 강한 비선형 |
| **계산 복잡도** | 낮음 | 중간 | 높음 |
| **정확도** | 선형계에서 최적 | 선형화 오차 | 높은 정확도 |
| **구현 난이도** | 쉬움 | 야코비안 필요 | 복잡함 |



---

## 🔑 전체 강의 총정리

### 🔑 핵심 개념 정리
1. **칼만 필터**: 불확실한 측정값들로부터 최적 상태 추정
2. **센서 융합**: 다중 센서의 장점 결합으로 성능 향상
3. **실제 구현**: 이론을 코드로 구현하며 깊이 이해
4. **한계 인식**: 현실적 제약 조건과 확장 방안 탐색

### 🌟 학습 성과
- 칼만 필터의 동작 원리 완전 이해
- 센서 융합의 필요성과 효과 체감
- 실제 코드 구현을 통한 실무 역량 획득
- 고급 필터링 기법에 대한 통찰 확보

### 🚀 다음 단계 학습 방향
- **다차원 칼만 필터**: 벡터와 행렬 연산 확장
- **EKF 구현**: 비선형 시스템 실제 적용
- **파티클 필터**: 더욱 복잡한 비선형/비가우시안 문제
- **실제 프로젝트**: 드론, 로봇 등 실제 시스템 적용

---



## 📚 참고 자료

- [Kalman Filter 원본 논문](https://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf)
- [Sebastian Thrun의 확률 로봇공학](https://probroboticsbook.org/)
- [Greg Welch & Gary Bishop의 칼만 필터 소개](https://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf)

---

⭐ 이 가이드가 도움이 되었다면 스타를 눌러주세요!
