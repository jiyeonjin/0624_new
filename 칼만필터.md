# ì¹¼ë§Œ í•„í„° ì •ë¦¬

[![GitHub stars](https://img.shields.io/github/stars/username/kalman-filter-guide.svg?style=social&label=Star)](https://github.com/username/kalman-filter-guide)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

> ë…¸ì´ì¦ˆê°€ ë§ì€ ì„¼ì„œ ë°ì´í„°ë¥¼ ê²°í•©í•˜ì—¬ ì‹¤ì‹œê°„ìœ¼ë¡œ ìµœì ì˜ ìƒíƒœë¥¼ ì¶”ì •í•˜ëŠ” ì¹¼ë§Œ í•„í„° ì •ë¦¬í•˜ê¸°

## ğŸ“‹ ëª©ì°¨

- [ì²« ë²ˆì§¸ ê°•ì˜: ì¹¼ë§Œ í•„í„°ì˜ ê¸°ì´ˆ](#-ì²«-ë²ˆì§¸-ê°•ì˜-ì¹¼ë§Œ-í•„í„°ì˜-ê¸°ì´ˆ)
- [ë‘ ë²ˆì§¸ ê°•ì˜: ì„¼ì„œ ìœµí•©ê³¼ ì¹¼ë§Œ í•„í„°](#-ë‘-ë²ˆì§¸-ê°•ì˜-ì„¼ì„œ-ìœµí•©ê³¼-ì¹¼ë§Œ-í•„í„°)
- [ì„¸ ë²ˆì§¸ ê°•ì˜: 1ì°¨ì› ì¹¼ë§Œ í•„í„° ì‹¬í™”](#-ì„¸-ë²ˆì§¸-ê°•ì˜-1ì°¨ì›-ì¹¼ë§Œ-í•„í„°-ì‹¬í™”)
- [ì „ì²´ ê°•ì˜ ì´ì •ë¦¬](#-ì „ì²´-ê°•ì˜-ì´ì •ë¦¬)

---

## ğŸ“š ì²« ë²ˆì§¸ ê°•ì˜: ì¹¼ë§Œ í•„í„°ì˜ ê¸°ì´ˆ

### ğŸ¯ ì¹¼ë§Œ í•„í„°ì˜ ê°œë…
ì¹¼ë§Œ í•„í„°(Kalman Filter)ëŠ” 1960ë…„ ë£¨ëŒí”„ ì¹¼ë§Œì´ ê°œë°œí•œ **ìµœì  ìƒíƒœ ì¶”ì • ì•Œê³ ë¦¬ì¦˜**ì…ë‹ˆë‹¤. ë…¸ì´ì¦ˆê°€ í¬í•¨ëœ ë¶ˆì™„ì „í•œ ì¸¡ì •ê°’ë“¤ì„ ì´ìš©í•´ ì‹œìŠ¤í…œì˜ ì‹¤ì œ ìƒíƒœë¥¼ ê°€ì¥ ì •í™•í•˜ê²Œ ì¶”ì •í•˜ëŠ” ìˆ˜í•™ì  ë„êµ¬ì…ë‹ˆë‹¤.

### ğŸ’¡ ì¹¼ë§Œ í•„í„°ì˜ í•µì‹¬ ì•„ì´ë””ì–´
- **ë² ì´ì§€ì•ˆ ì¶”ë¡ **: ì´ì „ ì •ë³´ì™€ ìƒˆë¡œìš´ ì¸¡ì •ê°’ì„ ê²°í•©
- **ì¬ê·€ì  ì¶”ì •**: ëª¨ë“  ê³¼ê±° ë°ì´í„°ë¥¼ ì €ì¥í•  í•„ìš” ì—†ì´ í˜„ì¬ ìƒíƒœë§Œìœ¼ë¡œ ìµœì  ì¶”ì •
- **ë¶ˆí™•ì‹¤ì„± ê´€ë¦¬**: ì¶”ì •ê°’ì˜ ì‹ ë¢°ë„(ê³µë¶„ì‚°)ë„ í•¨ê»˜ ê³„ì‚°

### âš™ï¸ ì¹¼ë§Œ í•„í„°ì˜ ë™ì‘ ì›ë¦¬

#### 1ë‹¨ê³„: ì˜ˆì¸¡ (Predict)
```
ë‹¤ìŒ ìƒíƒœë¥¼ ëª¨ë¸ë¡œ ì˜ˆì¸¡
xÌ‚(k|k-1) = F * xÌ‚(k-1|k-1) + B * u(k)
P(k|k-1) = F * P(k-1|k-1) * F^T + Q
```

#### 2ë‹¨ê³„: ì¸¡ì • (Measure)
```
ì„¼ì„œë¡œë¶€í„° ìƒˆë¡œìš´ ì¸¡ì •ê°’ z(k) íšë“
```

#### 3ë‹¨ê³„: ë³´ì • (Update)
```
ì¹¼ë§Œ ê²Œì¸ ê³„ì‚°: K(k) = P(k|k-1) * H^T * (H * P(k|k-1) * H^T + R)^(-1)
ìƒíƒœ ì—…ë°ì´íŠ¸: xÌ‚(k|k) = xÌ‚(k|k-1) + K(k) * (z(k) - H * xÌ‚(k|k-1))
ê³µë¶„ì‚° ì—…ë°ì´íŠ¸: P(k|k) = (I - K(k) * H) * P(k|k-1)
```

### ğŸŒ ì‹¤ìƒí™œ ì ìš© ì˜ˆì‹œ

#### ììœ¨ì£¼í–‰ ìë™ì°¨
- GPS, ë¼ì´ë‹¤, ì¹´ë©”ë¼ ë°ì´í„° ìœµí•©
- ì°¨ëŸ‰ì˜ ìœ„ì¹˜, ì†ë„, ê°€ì†ë„ ì‹¤ì‹œê°„ ì¶”ì •
- ì¥ì• ë¬¼ ì¶”ì  ë° ê²½ë¡œ ì˜ˆì¸¡

#### ë“œë¡  ì œì–´
- IMU, GPS, ê¸°ì••ê³„ ë°ì´í„° í†µí•©
- 3D ìœ„ì¹˜ ë° ìì„¸ ì•ˆì •í™”
- ë°”ëŒ ë“± ì™¸ë¶€ êµë€ ë³´ì •

#### ë¡œë´‡ ë„¤ë¹„ê²Œì´ì…˜
- ì—”ì½”ë”, ë¼ì´ë‹¤ ìŠ¤ìº” ë§¤ì¹­
- SLAM(ë™ì‹œ ìœ„ì¹˜ì¶”ì • ë° ì§€ë„ì‘ì„±)
- ë™ì  í™˜ê²½ì—ì„œì˜ ê²½ë¡œ ê³„íš

### ğŸ’» ê°„ë‹¨í•œ 1ì°¨ì› ì¹¼ë§Œ í•„í„° ì½”ë“œ

```python
import random

# ì¸¡ì • ì˜¤ì°¨ (ì„¼ì„œ ë…¸ì´ì¦ˆ ë“±)
measurement_error = 4.0  # ë¶„ì‚° 2.0^2 = 4.0

# ì‹¤ì œ ìœ„ì¹˜ëŠ” 0, ë…¸ì´ì¦ˆê°€ ì„ì¸ ì¸¡ì •ê°’ 10ê°œ ìƒì„±
measurements = [0 + random.gauss(0, 2.0) for _ in range(10)]

estimate = 0.0  # ì´ˆê¸° ì¶”ì •ê°’
error_in_estimate = 1.0  # ì´ˆê¸° ì¶”ì • ì˜¤ì°¨

# ì¹¼ë§Œ í•„í„° ì ìš©
for z in measurements:
    # ì¹¼ë§Œ ì´ë“ ê³„ì‚°
    K = error_in_estimate / (error_in_estimate + measurement_error)
    # ì¶”ì •ê°’ ê°±ì‹ 
    estimate = estimate + K * (z - estimate)
    # ì¶”ì • ì˜¤ì°¨ ê°±ì‹ 
    error_in_estimate = (1 - K) * error_in_estimate

print(f"ìµœì¢… ìˆ˜ì •ê°’: {estimate:.2f}")
```


### ğŸ“Š ì½”ë“œ ë¶„ì„

#### **Step 1: ì¹¼ë§Œ ê²Œì¸ ê³„ì‚°**
```python
K = error_in_estimate / (error_in_estimate + measurement_error)
```

**ìˆ˜í•™ì  ì˜ë¯¸:**
- K = P / (P + R)
- **P**: í˜„ì¬ ì¶”ì • ë¶ˆí™•ì‹¤ì„±
- **R**: ì¸¡ì • ë…¸ì´ì¦ˆ ë¶„ì‚°
- **ê²°ê³¼**: 0 â‰¤ K â‰¤ 1

**í•´ì„:**
- **K â‰ˆ 0**: ì¸¡ì •ê°’ë³´ë‹¤ í˜„ì¬ ì¶”ì •ì„ ë” ì‹ ë¢° (R >> P)
- **K â‰ˆ 1**: í˜„ì¬ ì¶”ì •ë³´ë‹¤ ì¸¡ì •ê°’ì„ ë” ì‹ ë¢° (P >> R)
- **K = 0.5**: ì¶”ì •ê³¼ ì¸¡ì •ì„ ë™ë“±í•˜ê²Œ ì‹ ë¢° (P = R)

#### **Step 2: ì¶”ì •ê°’ ê°±ì‹ **
```python
estimate = estimate + K * (z - estimate)
```

**ìˆ˜í•™ì  ì˜ë¯¸:**
- xÌ‚â‚™â‚‘w = xÌ‚â‚’â‚—d + K Ã— (ì¸¡ì •ê°’ - xÌ‚â‚’â‚—d)
- **(z - estimate)**: **í˜ì‹ (Innovation)** - ì¸¡ì •ê°’ê³¼ ì˜ˆì¸¡ê°’ì˜ ì°¨ì´
- **K Ã— í˜ì‹ **: ë³´ì •ëŸ‰

**í•´ì„:**
- í˜„ì¬ ì¶”ì •ê°’ì„ ì¸¡ì •ê°’ ë°©í–¥ìœ¼ë¡œ Kë§Œí¼ ì¡°ì •
- ê°€ì¤‘ í‰ê· ì˜ ê°œë…: (1-K) Ã— ì¶”ì • + K Ã— ì¸¡ì •

#### **Step 3: ë¶ˆí™•ì‹¤ì„± ê°±ì‹ **
```python
error_in_estimate = (1 - K) * error_in_estimate
```

**ìˆ˜í•™ì  ì˜ë¯¸:**
- Pâ‚™â‚‘w = (1 - K) Ã— Pâ‚’â‚—d
- ì¸¡ì • í›„ í•­ìƒ ë¶ˆí™•ì‹¤ì„±ì´ ê°ì†Œ

**í•´ì„:**
- ìƒˆë¡œìš´ ì •ë³´(ì¸¡ì •ê°’)ë¥¼ ì–»ìœ¼ë©´ ë¶ˆí™•ì‹¤ì„± ê°ì†Œ
- Kê°€ í´ìˆ˜ë¡ (ì¸¡ì •ì„ ë” ì‹ ë¢°) ë¶ˆí™•ì‹¤ì„±ì´ ë” ë§ì´ ê°ì†Œ

---

## ğŸ¯ í•µì‹¬ ê°œë… ì •ë¦¬

### 1ï¸âƒ£ ì´ ì½”ë“œì˜ íŠ¹ì§•
- **ì •ì  ì‹œìŠ¤í…œ**: ì‹¤ì œ ê°’ì´ ë³€í•˜ì§€ ì•ŠìŒ (ìœ„ì¹˜ = 0 ê³ ì •)
- **ì¸¡ì •ë§Œ ìˆìŒ**: ë™ì—­í•™ ëª¨ë¸ ì—†ì´ ìˆœìˆ˜ ì¸¡ì • ê¸°ë°˜ ì¶”ì •
- **1ì°¨ì›**: ê°€ì¥ ë‹¨ìˆœí•œ í˜•íƒœì˜ ì¹¼ë§Œ í•„í„°

### 2ï¸âƒ£ ì¹¼ë§Œ í•„í„°ì˜ í•µì‹¬ ì•„ì´ë””ì–´
```python
# ì´ì „ ì¶”ì • + ë³´ì • = ìƒˆë¡œìš´ ì¶”ì •
ìƒˆë¡œìš´_ì¶”ì • = ì´ì „_ì¶”ì • + ì¹¼ë§Œ_ê²Œì¸ Ã— (ì¸¡ì •ê°’ - ì´ì „_ì¶”ì •)
```

### 3ï¸âƒ£ ë¶ˆí™•ì‹¤ì„±ì˜ ì—­í• 
- **ë†’ì€ ë¶ˆí™•ì‹¤ì„±** â†’ **ë†’ì€ ì¹¼ë§Œ ê²Œì¸** â†’ **ì¸¡ì •ê°’ì— ë” ì˜ì¡´**
- **ë‚®ì€ ë¶ˆí™•ì‹¤ì„±** â†’ **ë‚®ì€ ì¹¼ë§Œ ê²Œì¸** â†’ **í˜„ì¬ ì¶”ì •ì„ ë” ì‹ ë¢°**

---

## ğŸ“¡ ë‘ ë²ˆì§¸ ê°•ì˜: ì„¼ì„œ ìœµí•©ê³¼ ì¹¼ë§Œ í•„í„°

### ğŸ¤” ì™œ ì„¼ì„œ ìœµí•©ì´ í•„ìš”í•œê°€?

#### ë‹¨ì¼ ì„¼ì„œì˜ í•œê³„
- **ë…¸ì´ì¦ˆì™€ ì˜¤ì°¨**: ëª¨ë“  ì„¼ì„œëŠ” ë¶ˆì™„ì „í•¨
- **í™˜ê²½ ì˜ì¡´ì„±**: íŠ¹ì • ì¡°ê±´ì—ì„œ ì„±ëŠ¥ ì €í•˜
- **ë‹¨ì¼ ì‹¤íŒ¨ì **: ì„¼ì„œ ê³ ì¥ ì‹œ ì‹œìŠ¤í…œ ì „ì²´ ë§ˆë¹„
- **ì œí•œëœ ì •ë³´**: í•˜ë‚˜ì˜ ì„¼ì„œë¡œëŠ” ì „ì²´ ìƒí™© íŒŒì•… ì–´ë ¤ì›€

#### ì„¼ì„œ ìœµí•©ì˜ ì¥ì 
- **ì •í™•ë„ í–¥ìƒ**: ì—¬ëŸ¬ ì¸¡ì •ê°’ì˜ í†µê³„ì  ê²°í•©
- **ì‹ ë¢°ì„± ì¦ëŒ€**: ì„¼ì„œ ê°„ ìƒí˜¸ ê²€ì¦
- **ê°•ê±´ì„±**: ì¼ë¶€ ì„¼ì„œ ì‹¤íŒ¨ì—ë„ ë™ì‘ ì§€ì†
- **ì™„ì „í•œ ìƒíƒœ ì¶”ì •**: ë‹¤ì–‘í•œ ë¬¼ë¦¬ëŸ‰ ë™ì‹œ ì¸¡ì •

### ğŸ“Š ì£¼ìš” ì„¼ì„œ ë¹„êµ: GPS vs IMU

| íŠ¹ì„± | GPS | IMU (ê´€ì„±ì¸¡ì •ì¥ì¹˜) |
|------|-----|-------------------|
| **ì¥ì ** | â€¢ ì ˆëŒ€ ìœ„ì¹˜ ì •ë³´<br>â€¢ ì¥ê¸°ê°„ ë“œë¦¬í”„íŠ¸ ì—†ìŒ<br>â€¢ ê¸€ë¡œë²Œ ì¢Œí‘œê³„ | â€¢ ë†’ì€ ìƒ˜í”Œë§ ì£¼íŒŒìˆ˜<br>â€¢ ì‹¤ë‚´/í„°ë„ì—ì„œë„ ë™ì‘<br>â€¢ ì§§ì€ ì§€ì—°ì‹œê°„ |
| **ë‹¨ì ** | â€¢ ì‹¤ë‚´ì—ì„œ ì‹ í˜¸ ì°¨ë‹¨<br>â€¢ ë‚®ì€ ì—…ë°ì´íŠ¸ ì£¼íŒŒìˆ˜<br>â€¢ ë‚ ì”¨/ê±´ë¬¼ ì˜í–¥ | â€¢ ì‹œê°„ì— ë”°ë¥¸ ë“œë¦¬í”„íŠ¸<br>â€¢ ì ë¶„ ì˜¤ì°¨ ëˆ„ì <br>â€¢ ë°”ì´ì–´ìŠ¤ì™€ ë…¸ì´ì¦ˆ |
| **ì—…ë°ì´íŠ¸ ì£¼íŒŒìˆ˜** | 1-10 Hz | 100-1000 Hz |
| **ì •í™•ë„** | ìˆ˜ ë¯¸í„° | ë‹¨ê¸°ê°„ ë§¤ìš° ì •í™• |

### ğŸ”„ ì„¼ì„œ ìœµí•©ì˜ ìƒí˜¸ ë³´ì™„ ê´€ê³„

#### GPS + IMU ìœµí•©ì˜ ì‹œë„ˆì§€
- **GPS**: ì¥ê¸°ê°„ ì•ˆì •ì„±, ì ˆëŒ€ ê¸°ì¤€ì  ì œê³µ
- **IMU**: ê³ ì£¼íŒŒ ì—…ë°ì´íŠ¸, ìˆœê°„ì  ì›€ì§ì„ ê°ì§€
- **ê²°í•© íš¨ê³¼**: GPSë¡œ IMU ë“œë¦¬í”„íŠ¸ ë³´ì •, IMUë¡œ GPS ê°­ ë³´ê°„

#### ìœµí•© ê³¼ì •ì˜ ì‹œê°ì  ì´í•´
```
ì‹œê°„ ì¶•: |-------|-------|-------|-------|
GPS:     â—               â—               â—
IMU:     â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—
ìœµí•©:    â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—
```

### âš¡ ì¹¼ë§Œ í•„í„°ì˜ ì„¼ì„œ ìœµí•© ê³¼ì •

#### 1ë‹¨ê³„: ë‹¤ì¤‘ ì„¼ì„œ ëª¨ë¸ë§
```python
# ìƒíƒœ ë²¡í„°: [ìœ„ì¹˜, ì†ë„]
x = [position, velocity]

# GPS ì¸¡ì • ëª¨ë¸
H_gps = [1, 0]  # ìœ„ì¹˜ë§Œ ì¸¡ì •

# IMU ì¸¡ì • ëª¨ë¸  
H_imu = [0, 1]  # ê°€ì†ë„ì—ì„œ ì†ë„ ìœ ë„
```

#### 2ë‹¨ê³„: ë¹„ë™ê¸° ì„¼ì„œ ì²˜ë¦¬
```python
def sensor_fusion_step(dt):
    # ì˜ˆì¸¡ (ì‹œìŠ¤í…œ ë™ì—­í•™)
    predict(dt)
    
    # GPS ë°ì´í„° ìˆìœ¼ë©´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
    if gps_available:
        update_with_gps(gps_measurement)
    
    # IMU ë°ì´í„°ë¡œ ì†ë„/ê°€ì†ë„ ì—…ë°ì´íŠ¸
    if imu_available:
        update_with_imu(imu_measurement)
```

#### 3ë‹¨ê³„: ì ì‘ì  ë…¸ì´ì¦ˆ ì¡°ì •
```python
# ì„¼ì„œ í’ˆì§ˆì— ë”°ë¥¸ ë…¸ì´ì¦ˆ ì¡°ì •
if gps_signal_strong:
    R_gps = low_noise
else:
    R_gps = high_noise
```

### ğŸ“ˆ ì„¼ì„œ ìœµí•© íš¨ê³¼ ì‹œê°í™”

#### ìœµí•© ì „í›„ ë¹„êµ
- **GPSë§Œ ì‚¬ìš©**: ê³„ë‹¨ì‹ ìœ„ì¹˜ ì¶”ì •, ê°­ êµ¬ê°„ ì •ë³´ ì—†ìŒ
- **IMUë§Œ ì‚¬ìš©**: ë¶€ë“œëŸ¬ìš´ ì¶”ì •ì´ì§€ë§Œ ì‹œê°„ì— ë”°ë¥¸ ë“œë¦¬í”„íŠ¸
- **ìœµí•© ê²°ê³¼**: GPSì˜ ì •í™•ì„± + IMUì˜ ì—°ì†ì„±

#### ë¶ˆí™•ì‹¤ì„±ì˜ ë³€í™”
- GPS ì¸¡ì • ì‹œ: ìœ„ì¹˜ ë¶ˆí™•ì‹¤ì„± ê¸‰ê²©íˆ ê°ì†Œ
- IMU ì—…ë°ì´íŠ¸: ì†ë„ ë¶ˆí™•ì‹¤ì„± ê°ì†Œ, ìœ„ì¹˜ëŠ” ì ì§„ì  ì¦ê°€
- ìœµí•© íš¨ê³¼: ì „ì²´ì ì¸ ë¶ˆí™•ì‹¤ì„± ìµœì†Œí™”

### ğŸ¯ ì„¼ì„œ ìœµí•© í•µì‹¬ ì›ë¦¬
> **ê° ì„¼ì„œì˜ ì¥ì ì€ ì‚´ë¦¬ê³  ë‹¨ì ì€ ë³´ì™„í•˜ì—¬, ë‹¨ì¼ ì„¼ì„œë¡œëŠ” ë¶ˆê°€ëŠ¥í•œ ì •í™•í•˜ê³  ì—°ì†ì ì¸ ìƒíƒœ ì¶”ì •ì„ ì‹¤í˜„í•©ë‹ˆë‹¤.**

---

## ğŸ”§ ì„¸ ë²ˆì§¸ ê°•ì˜: 1ì°¨ì› ì¹¼ë§Œ í•„í„° ì‹¬í™”

### ğŸ’» ìƒì„¸í•œ 1ì°¨ì› ì¹¼ë§Œ í•„í„° êµ¬í˜„

```python
import numpy as np
import matplotlib.pyplot as plt

class DetailedKalmanFilter1D:
    def __init__(self, initial_state, initial_covariance, process_noise, measurement_noise):
        """
        1ì°¨ì› ì¹¼ë§Œ í•„í„° ì´ˆê¸°í™”
        
        Args:
            initial_state: ì´ˆê¸° ìƒíƒœ ì¶”ì •ê°’
            initial_covariance: ì´ˆê¸° ì¶”ì • ë¶ˆí™•ì‹¤ì„±
            process_noise: ì‹œìŠ¤í…œ ëª¨ë¸ ë…¸ì´ì¦ˆ (Q)
            measurement_noise: ì„¼ì„œ ì¸¡ì • ë…¸ì´ì¦ˆ (R)
        """
        # ìƒíƒœ ì¶”ì •ê°’ê³¼ ê³µë¶„ì‚°
        self.x = initial_state
        self.P = initial_covariance
        
        # ë…¸ì´ì¦ˆ ë§¤ê°œë³€ìˆ˜
        self.Q = process_noise
        self.R = measurement_noise
        
        # ìƒíƒœ ì „ì´ ëª¨ë¸ (ë“±ì† ìš´ë™)
        self.F = 1.0  # 1ì°¨ì›ì—ì„œëŠ” ìŠ¤ì¹¼ë¼
        self.H = 1.0  # ì¸¡ì • ëª¨ë¸
        
        # ê¸°ë¡ìš©
        self.history = {
            'states': [],
            'covariances': [],
            'kalman_gains': [],
            'innovations': []
        }
    
    def predict(self):
        """
        ì˜ˆì¸¡ ë‹¨ê³„ (Prediction Step)
        - ì‹œìŠ¤í…œ ë™ì—­í•™ì— ë”°ë¥¸ ë‹¤ìŒ ìƒíƒœ ì˜ˆì¸¡
        - ë¶ˆí™•ì‹¤ì„± ì¦ê°€ (ì‹œìŠ¤í…œ ë…¸ì´ì¦ˆ ì¶”ê°€)
        """
        # ìƒíƒœ ì˜ˆì¸¡: xÌ‚(k|k-1) = F * xÌ‚(k-1|k-1)
        self.x = self.F * self.x
        
        # ê³µë¶„ì‚° ì˜ˆì¸¡: P(k|k-1) = F * P(k-1|k-1) * F^T + Q
        self.P = self.F * self.P * self.F + self.Q
        
        print(f"ì˜ˆì¸¡ í›„ - ìƒíƒœ: {self.x:.3f}, ë¶ˆí™•ì‹¤ì„±: {self.P:.3f}")
    
    def update(self, measurement):
        """
        ê°±ì‹  ë‹¨ê³„ (Update Step)
        - ì¸¡ì •ê°’ìœ¼ë¡œ ìƒíƒœ ì¶”ì •ê°’ ë³´ì •
        - ë¶ˆí™•ì‹¤ì„± ê°ì†Œ
        """
        # í˜ì‹ (innovation): ì¸¡ì •ê°’ê³¼ ì˜ˆì¸¡ê°’ì˜ ì°¨ì´
        innovation = measurement - self.H * self.x
        
        # í˜ì‹  ê³µë¶„ì‚°: S = H * P * H^T + R
        S = self.H * self.P * self.H + self.R
        
        # ì¹¼ë§Œ ê²Œì¸: K = P * H^T * S^(-1)
        K = self.P * self.H / S
        
        # ìƒíƒœ ê°±ì‹ : xÌ‚(k|k) = xÌ‚(k|k-1) + K * innovation
        self.x = self.x + K * innovation
        
        # ê³µë¶„ì‚° ê°±ì‹ : P(k|k) = (I - K * H) * P(k|k-1)
        self.P = (1 - K * self.H) * self.P
        
        # ê¸°ë¡ ì €ì¥
        self.history['states'].append(self.x)
        self.history['covariances'].append(self.P)
        self.history['kalman_gains'].append(K)
        self.history['innovations'].append(innovation)
        
        print(f"ê°±ì‹  í›„ - ìƒíƒœ: {self.x:.3f}, ë¶ˆí™•ì‹¤ì„±: {self.P:.3f}, ì¹¼ë§Œê²Œì¸: {K:.3f}")
        
        return self.x, self.P

# ì‹¤ì œ ì ìš© ì˜ˆì œ: ì˜¨ë„ ì„¼ì„œ ë°ì´í„° í•„í„°ë§
def temperature_tracking_example():
    """ì‹¤ì œ ì˜¨ë„ë¥¼ ì¶”ì •í•˜ëŠ” ì˜ˆì œ"""
    
    # ì‹¤ì œ ì˜¨ë„ (ì•Œë ¤ì§€ì§€ ì•Šì€ ì°¸ê°’)
    true_temperature = 25.0
    
    # ë…¸ì´ì¦ˆê°€ ìˆëŠ” ì„¼ì„œ ì¸¡ì •ê°’ ìƒì„±
    np.random.seed(42)
    measurements = true_temperature + np.random.normal(0, 2, 20)
    
    # ì¹¼ë§Œ í•„í„° ì´ˆê¸°í™”
    kf = DetailedKalmanFilter1D(
        initial_state=20.0,      # ì´ˆê¸° ì¶”ì •: 20ë„
        initial_covariance=10.0,  # ì´ˆê¸° ë¶ˆí™•ì‹¤ì„±ì´ í¼
        process_noise=0.01,       # ì˜¨ë„ëŠ” ì²œì²œíˆ ë³€í•¨
        measurement_noise=4.0     # ì„¼ì„œ ë…¸ì´ì¦ˆ ë¶„ì‚°
    )
    
    estimates = []
    uncertainties = []
    
    print("=== ì˜¨ë„ ì„¼ì„œ ì¹¼ë§Œ í•„í„°ë§ ===")
    
    for i, measurement in enumerate(measurements):
        print(f"\nì‹œê°„ {i+1}: ì¸¡ì •ê°’ = {measurement:.2f}Â°C")
        
        # ì¹¼ë§Œ í•„í„° ë‹¨ê³„ ì‹¤í–‰
        kf.predict()
        estimate, uncertainty = kf.update(measurement)
        
        estimates.append(estimate)
        uncertainties.append(uncertainty)
    
    # ê²°ê³¼ ì‹œê°í™”
    plt.figure(figsize=(12, 8))
    
    # ìƒíƒœ ì¶”ì • ê²°ê³¼
    plt.subplot(2, 2, 1)
    plt.plot(measurements, 'r.', label='ì¸¡ì •ê°’', alpha=0.7)
    plt.plot(estimates, 'b-', label='ì¹¼ë§Œ í•„í„° ì¶”ì •', linewidth=2)
    plt.axhline(y=true_temperature, color='g', linestyle='--', label='ì‹¤ì œ ì˜¨ë„')
    plt.fill_between(range(len(estimates)), 
                     np.array(estimates) - np.sqrt(uncertainties),
                     np.array(estimates) + np.sqrt(uncertainties),
                     alpha=0.3, label='Â±1Ïƒ ì‹ ë¢°êµ¬ê°„')
    plt.xlabel('ì‹œê°„')
    plt.ylabel('ì˜¨ë„ (Â°C)')
    plt.title('ì¹¼ë§Œ í•„í„° ì˜¨ë„ ì¶”ì •')
    plt.legend()
    plt.grid(True)
    
    # ë¶ˆí™•ì‹¤ì„± ë³€í™”
    plt.subplot(2, 2, 2)
    plt.plot(uncertainties, 'g-', linewidth=2)
    plt.xlabel('ì‹œê°„')
    plt.ylabel('ë¶„ì‚°')
    plt.title('ì¶”ì • ë¶ˆí™•ì‹¤ì„± ë³€í™”')
    plt.grid(True)
    
    # ì¹¼ë§Œ ê²Œì¸ ë³€í™”
    plt.subplot(2, 2, 3)
    plt.plot(kf.history['kalman_gains'], 'm-', linewidth=2)
    plt.xlabel('ì‹œê°„')
    plt.ylabel('ì¹¼ë§Œ ê²Œì¸')
    plt.title('ì¹¼ë§Œ ê²Œì¸ ë³€í™”')
    plt.grid(True)
    
    # í˜ì‹ (ì”ì°¨) ë¶„ì„
    plt.subplot(2, 2, 4)
    plt.plot(kf.history['innovations'], 'c-', linewidth=2)
    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.xlabel('ì‹œê°„')
    plt.ylabel('í˜ì‹  (ì¸¡ì •ê°’ - ì˜ˆì¸¡ê°’)')
    plt.title('í˜ì‹  ì‹œê³„ì—´')
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    print(f"\n=== ìµœì¢… ê²°ê³¼ ===")
    print(f"ì‹¤ì œ ì˜¨ë„: {true_temperature:.2f}Â°C")
    print(f"ìµœì¢… ì¶”ì •: {estimates[-1]:.2f}Â°C")
    print(f"ì¶”ì • ì˜¤ì°¨: {abs(estimates[-1] - true_temperature):.2f}Â°C")
    print(f"ìµœì¢… ë¶ˆí™•ì‹¤ì„±: {uncertainties[-1]:.4f}")

# ì‹¤í–‰
temperature_tracking_example()
```

### ğŸ” ì½”ë“œì˜ ê° ë¼ì¸ê³¼ ì¹¼ë§Œ í•„í„° ì´ë¡  ì—°ê²°

#### ì˜ˆì¸¡ ë‹¨ê³„ (Predict)
```python
# ìƒíƒœ ì˜ˆì¸¡
self.x = self.F * self.x
```
â†’ **ì´ë¡ **: xÌ‚(k|k-1) = FÂ·xÌ‚(k-1|k-1)
â†’ **ì˜ë¯¸**: ì´ì „ ìƒíƒœì—ì„œ ì‹œìŠ¤í…œ ëª¨ë¸ë¡œ ë‹¤ìŒ ìƒíƒœ ì˜ˆì¸¡

```python
# ê³µë¶„ì‚° ì˜ˆì¸¡
self.P = self.F * self.P * self.F + self.Q
```
â†’ **ì´ë¡ **: P(k|k-1) = FÂ·P(k-1|k-1)Â·F^T + Q
â†’ **ì˜ë¯¸**: ì˜ˆì¸¡ ê³¼ì •ì—ì„œ ë¶ˆí™•ì‹¤ì„± ì¦ê°€ (ì‹œìŠ¤í…œ ë…¸ì´ì¦ˆ ì¶”ê°€)

#### ê°±ì‹  ë‹¨ê³„ (Update)
```python
# ì¹¼ë§Œ ê²Œì¸ ê³„ì‚°
K = self.P * self.H / S
```
â†’ **ì´ë¡ **: K = PÂ·H^TÂ·S^(-1)
â†’ **ì˜ë¯¸**: ì˜ˆì¸¡ê³¼ ì¸¡ì •ê°’ ì¤‘ ì–´ëŠ ê²ƒì„ ë” ì‹ ë¢°í• ì§€ ê²°ì •

```python
# ìƒíƒœ ê°±ì‹ 
self.x = self.x + K * innovation
```
â†’ **ì´ë¡ **: xÌ‚(k|k) = xÌ‚(k|k-1) + KÂ·(z - HÂ·xÌ‚(k|k-1))
â†’ **ì˜ë¯¸**: ì¸¡ì •ê°’ê³¼ ì˜ˆì¸¡ê°’ì˜ ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ìµœì  ì¶”ì •

### âš ï¸ ì¹¼ë§Œ í•„í„°ì˜ ê·¼ë³¸ì ì¸ í•œê³„

#### 1. ì„ í˜•ì„± ê°€ì • (Linearity Assumption)
```python
# ì¹¼ë§Œ í•„í„°ëŠ” ì„ í˜• ì‹œìŠ¤í…œë§Œ ì²˜ë¦¬ ê°€ëŠ¥
x(k) = F * x(k-1) + B * u(k) + w(k)  # ì„ í˜• ìƒíƒœ ë°©ì •ì‹
z(k) = H * x(k) + v(k)               # ì„ í˜• ì¸¡ì • ë°©ì •ì‹
```

**ë¬¸ì œìƒí™©**:
- íšŒì „ ìš´ë™ (ì‚¼ê°í•¨ìˆ˜ í¬í•¨)
- ë¹„ì„ í˜• ì„¼ì„œ íŠ¹ì„±
- ë³µì¡í•œ ë¬¼ë¦¬ í˜„ìƒ

**í•œê³„ ì˜ˆì‹œ**:
```python
# ì´ëŸ° ë¹„ì„ í˜• ì‹œìŠ¤í…œì€ ì²˜ë¦¬ ë¶ˆê°€
def nonlinear_model(x):
    return np.sin(x) + x**2  # ë¹„ì„ í˜• í•¨ìˆ˜
```

#### 2. ê°€ìš°ì‹œì•ˆ ë…¸ì´ì¦ˆ ê°€ì •
```python
# ëª¨ë“  ë…¸ì´ì¦ˆê°€ ì •ê·œë¶„í¬ë¥¼ ë”°ë¥¸ë‹¤ê³  ê°€ì •
process_noise ~ N(0, Q)      # ì‹œìŠ¤í…œ ë…¸ì´ì¦ˆ
measurement_noise ~ N(0, R)  # ì„¼ì„œ ë…¸ì´ì¦ˆ
```

**ë¬¸ì œìƒí™©**:
- ì´ìƒì¹˜(outlier)ê°€ ë§ì€ ì„¼ì„œ
- ë¹„ëŒ€ì¹­ ë…¸ì´ì¦ˆ ë¶„í¬
- ê°„í—ì  ëŒ€í˜• ì˜¤ì°¨

#### 3. ëª¨ë¸ ì •í™•ì„± ì˜ì¡´
- ì˜ëª»ëœ F, H í–‰ë ¬ ì„¤ì • ì‹œ ì„±ëŠ¥ ì €í•˜
- Q, R ë§¤ê°œë³€ìˆ˜ íŠœë‹ì˜ ì–´ë ¤ì›€
- ì‹œë³€ ì‹œìŠ¤í…œì— ëŒ€í•œ ì ì‘ì„± ë¶€ì¡±

### ğŸš€ í™•ì¥ëœ ì¹¼ë§Œ í•„í„°ì˜ í•„ìš”ì„±

#### Extended Kalman Filter (EKF)
```python
# ë¹„ì„ í˜• í•¨ìˆ˜ë¥¼ ì„ í˜•í™”í•˜ì—¬ ì‚¬ìš©
def ekf_predict(x, dt):
    # ë¹„ì„ í˜• ìƒíƒœ ì „ì´
    x_pred = nonlinear_f(x, dt)
    
    # ì•¼ì½”ë¹„ì•ˆ í–‰ë ¬ë¡œ ì„ í˜•í™”
    F = jacobian_f(x, dt)
    P_pred = F @ P @ F.T + Q
    
    return x_pred, P_pred
```

**ì¥ì **: ë¹„ì„ í˜• ì‹œìŠ¤í…œ ì²˜ë¦¬ ê°€ëŠ¥
**ë‹¨ì **: ì•¼ì½”ë¹„ì•ˆ ê³„ì‚° ë³µì¡, ì„ í˜•í™” ì˜¤ì°¨

#### Unscented Kalman Filter (UKF)
```python
# ì‹œê·¸ë§ˆ í¬ì¸íŠ¸ë¡œ ë¹„ì„ í˜•ì„± ê·¼ì‚¬
def ukf_predict(x, P):
    # ì‹œê·¸ë§ˆ í¬ì¸íŠ¸ ìƒì„±
    sigma_points = generate_sigma_points(x, P)
    
    # ê° í¬ì¸íŠ¸ë¥¼ ë¹„ì„ í˜• í•¨ìˆ˜ì— í†µê³¼
    transformed_points = [nonlinear_f(sp) for sp in sigma_points]
    
    # í†µê³„ì ìœ¼ë¡œ í‰ê· ê³¼ ê³µë¶„ì‚° ì¶”ì •
    x_pred = weighted_mean(transformed_points)
    P_pred = weighted_covariance(transformed_points)
    
    return x_pred, P_pred
```

**ì¥ì **: ì•¼ì½”ë¹„ì•ˆ ë¶ˆí•„ìš”, ë” ì •í™•í•œ ë¹„ì„ í˜• ê·¼ì‚¬
**ë‹¨ì **: ê³„ì‚°ëŸ‰ ì¦ê°€

### ğŸ“Š í•œê³„ ê·¹ë³µ ì „ëµ ë¹„êµ

| íŠ¹ì„± | ì¹¼ë§Œ í•„í„° | EKF | UKF |
|------|-----------|-----|-----|
| **ì ìš© ëŒ€ìƒ** | ì„ í˜• ì‹œìŠ¤í…œ | ì•½í•œ ë¹„ì„ í˜• | ê°•í•œ ë¹„ì„ í˜• |
| **ê³„ì‚° ë³µì¡ë„** | ë‚®ìŒ | ì¤‘ê°„ | ë†’ìŒ |
| **ì •í™•ë„** | ì„ í˜•ê³„ì—ì„œ ìµœì  | ì„ í˜•í™” ì˜¤ì°¨ | ë†’ì€ ì •í™•ë„ |
| **êµ¬í˜„ ë‚œì´ë„** | ì‰¬ì›€ | ì•¼ì½”ë¹„ì•ˆ í•„ìš” | ë³µì¡í•¨ |



---

## ğŸ”‘ ì „ì²´ ê°•ì˜ ì´ì •ë¦¬

### ğŸ”‘ í•µì‹¬ ê°œë… ì •ë¦¬
1. **ì¹¼ë§Œ í•„í„°**: ë¶ˆí™•ì‹¤í•œ ì¸¡ì •ê°’ë“¤ë¡œë¶€í„° ìµœì  ìƒíƒœ ì¶”ì •
2. **ì„¼ì„œ ìœµí•©**: ë‹¤ì¤‘ ì„¼ì„œì˜ ì¥ì  ê²°í•©ìœ¼ë¡œ ì„±ëŠ¥ í–¥ìƒ
3. **ì‹¤ì œ êµ¬í˜„**: ì´ë¡ ì„ ì½”ë“œë¡œ êµ¬í˜„í•˜ë©° ê¹Šì´ ì´í•´
4. **í•œê³„ ì¸ì‹**: í˜„ì‹¤ì  ì œì•½ ì¡°ê±´ê³¼ í™•ì¥ ë°©ì•ˆ íƒìƒ‰

### ğŸŒŸ í•™ìŠµ ì„±ê³¼
- ì¹¼ë§Œ í•„í„°ì˜ ë™ì‘ ì›ë¦¬ ì™„ì „ ì´í•´
- ì„¼ì„œ ìœµí•©ì˜ í•„ìš”ì„±ê³¼ íš¨ê³¼ ì²´ê°
- ì‹¤ì œ ì½”ë“œ êµ¬í˜„ì„ í†µí•œ ì‹¤ë¬´ ì—­ëŸ‰ íšë“
- ê³ ê¸‰ í•„í„°ë§ ê¸°ë²•ì— ëŒ€í•œ í†µì°° í™•ë³´

### ğŸš€ ë‹¤ìŒ ë‹¨ê³„ í•™ìŠµ ë°©í–¥
- **ë‹¤ì°¨ì› ì¹¼ë§Œ í•„í„°**: ë²¡í„°ì™€ í–‰ë ¬ ì—°ì‚° í™•ì¥
- **EKF êµ¬í˜„**: ë¹„ì„ í˜• ì‹œìŠ¤í…œ ì‹¤ì œ ì ìš©
- **íŒŒí‹°í´ í•„í„°**: ë”ìš± ë³µì¡í•œ ë¹„ì„ í˜•/ë¹„ê°€ìš°ì‹œì•ˆ ë¬¸ì œ
- **ì‹¤ì œ í”„ë¡œì íŠ¸**: ë“œë¡ , ë¡œë´‡ ë“± ì‹¤ì œ ì‹œìŠ¤í…œ ì ìš©

---



## ğŸ“š ì°¸ê³  ìë£Œ

- [Kalman Filter ì›ë³¸ ë…¼ë¬¸](https://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf)
- [Sebastian Thrunì˜ í™•ë¥  ë¡œë´‡ê³µí•™](https://probroboticsbook.org/)
- [Greg Welch & Gary Bishopì˜ ì¹¼ë§Œ í•„í„° ì†Œê°œ](https://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf)

---

â­ ì´ ê°€ì´ë“œê°€ ë„ì›€ì´ ë˜ì—ˆë‹¤ë©´ ìŠ¤íƒ€ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”!
